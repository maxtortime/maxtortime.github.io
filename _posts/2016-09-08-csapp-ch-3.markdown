---
layout: post
title: "CSAPP: Ch 3."
date: "2016-09-08 01:41:09 +0900"
---
> Machine level Represenatation of Programs

*Taehwan Kim :email: maxtortime@ajou.ac.kr*

# 프로그램은 무엇으로 이루어져 있나?
* 컴퓨터가 실행하는 것은 기계어.
* 기계어는 *컴파일러->어셈블러->링커* 의 과정을 거쳐 만들어진다.
* 요즘 컴파일러들은 숙련된 어셈블리 프로그래머들이 짜는 것과 비슷한 어셈블리 코드를 만들어낸다.

# 고급언어의 유용함
* 이제 배우면 알겠지만 어셈블리는 너무 어렵다..
* C언어로 프로그램을 짜면 `gcc`로 컴파일만 해주면 코드를 재활용 할 수 있다.
* 하지만 어셈블리로 코딩을 하면 CPU 종류마다 코드를 다 다르게 짜야 한다..!!
* 너무 불편한거 아닌가?

# 하지만 어셈블리를 배워야 하는 이유
1. 컴파일러 최적화에 대해 이해할 수 있음.
2. 반복된 컴파일 과정 속에서 나오는 어셈블리의 성능을 측정해 성능을 극대화할 수 있다.
3. 고급언어가 추상화하는 프로그램의 런타임 행동을 이해할 수 있음.
4. 고급 언어의 쓰레드 패키지를 통해 동시 프로그래밍을 할 때 공유 자원이 오가는 것을 머신 레벨에서 파악 가능.
5. 프로그램의 취약점을 방어할 수 있다.

# 3.2 Program Encodings
책에서는 `gcc`, `x86_64` 기준으로 설명하고 있음. gcc 버전에 따라 어셈코드가 달라 보일 수 있음 (실제 경험함)

# 컴파일 과정 요약
1. 전처리기가 코드를 복붙하거나 매크로(`#define`)를 정의함
2. 컴파일러가 코드를 어셈블리로 바꿈
3. 어셈블러가 어셈블리를 이진 오브젝트 코드로 바꿈
4. 링커가 오브젝트 코드들을 실제 코드가 구현된 라이브러리의 주소와 일치시켜서 마침내 실행 가능한 프로그램을 만든다.

자세한 것은 7장에서...

# 머신레벨 프로그래밍에서 중요한 것
1. 프로그램의 포맷과 행동은 *ISA(Instruction set architectue)* 에 의해 결정됨.
2. 사용되는 메모리 주소는 모두 *Virtual addresses* 이다.
3. 보여지는 프로세서 상태의 대부분은 C 프로그래머에게 감쳐줘 있음.

# 레지스터의 종류
* *Program Counter* (PC, %rip(x86_64): 다음 명령이 실행될 메모리 주소
* 정수 *register file* : 64비트의 값을 담는 16개의 이름이 있는 위치, C포인터와 대응하는 주소나 정수 값을 저장.
* *Condition code register* 최근에 실행된 산술 혹은 논리 명령의 상태 정보를 담고 있음.
* *벡터 레지스터*: 하나 이상의 정수나 부동소수점(float) 값을 저장

# 머신 레벨 메모리
* C언어는 메모리를 점유할 수 있는 여러 데이터 타입들을 제공하지만, 기계어는 메모리를 거대한 주소로 접근가능한 바이트들의 배열로 본다.
* 프로그램은 가상 주소를 사용하며 `x86_6`4의 가상 주소의 경우 64비트 워드로 표현됨.
* 상위 16비트는 반드시 0이여야 함. 그러므로 주소는 2의 48 (64TB)만큼의 범위를 잠재적으로 지정 가능.
* 운영체제는 이러한 가상 주소 공간을 관리해서 가상 주소를 실제 프로세서 메모리의 물리적인 값으로 바꾼다.

# 링커의 역할
* 링커는 코드의 위치를 다른 주소 범위로 옮긴다. 즉, 실제로 호출될 함수의 주소와 이름으로 `callq` 명령어의 인자를 바꿈.
* 또한 함수 호출을 실행가능한 코드의 위치로 대체함.
* 코드 블록이 16바이트가 되지 않으면 `return`(`req`) 다음에 `nop`라는 명령어가 삽입되지만 아무일도 하지 않고 단지 메모리 시스템의 성능을 위한 것이다.

# 3.3. Data Formats

| C declaration |  Intel data type | Assembly-code suffix | Size (bytes) |
|:-------------:|:----------------:|:--------------------:|:------------:|
| char          | Byte             |           b          |       1      |
| short         | Word             |           w          |       2      |
| int           | Double word      |           l          |       4      |
| long          | Quad word        |           q          |       8      |
| char *        | Quad word        |           q          |       8      |
| float         | Single precision |           s          |       4      |
| double        | Double precision |           l          |       8      |

# 부동 소수점 포맷
부동소수점 수는 두가지의 포맷으로 나뉜다.
- Single-precision (4 바이트) 값, C의 float 와 대응함.
- Double-precision (8 바이트) 값, C의 double 과 대응함

또한 x86계열의 프로세서들은 역사적으로 특별한 80비트 (10바이트) all floating-point 명령을 이용했다. (호환되지 않을 수 있음)

# 3.4 Accessing Information (Figure 3.2)
* x86_64 CPU는 64비트 값을 담기 위한 16개의 general-purpose-registers 를 가지고 있다. 레지스터들의 이름은 %r 로 시작함.
* 명령어들은 16개 레지스터의 낮은 순서의 바이트에 저장된 서로 다른 사이즈의 데이터를 운용할 수 있다. (16비트 명령어는 마지막 2바이트, 32비트는 마지막 4바이트, 64비트는 전체 레지스터)
* Stack pointer 인 `%pstp` 는 런타임 스택에서 마지막 자리를 가리키는 데 쓰인다. 몇몇 명령어들은 이 레지스터에 I/O를 수행함.

# 3.4.1 Operand Specifiers
명령어의 피연산자는 아래 세가지 타입으로 분류된다.

- immediate: 상수를 의미함. ATT 포맷의 어셈블리에서는 $ 뒤에 정수가 붙음. ($-577 or $0x1F) 어셈블러는 값이 몇진법인지 알아서 결정함.
- register: 레지스터의 내용을 의미함. r<sub>a</sub>라는 기호는 레지스터 `a`라는 레지스터를 말하고, R[r<sub>a</sub>]라는 값을 가리키고 있음.
- memory: 계산된 주소를 통해 어떤 메모리 위치에 접근하는 용도이다. 이를 `effective address`라고 함. M<sub>b</sub> [Addr] 이라는 것은 b 바이트만큼의 값이 Addr이라는 주소에서부터 저장되어 있다는 걸 말한다.

# Operand forms (Figure 3.3)
* 가장 일반적인 형태는 *Imm(r<sub>b</sub>,r<sub>i</sub>,s)* 이다.
* 위 형태는 Imm+R[r<sub>b</sub>]+R[r<sub>i</sub>]*s 로 계산됨. 이런 형태는 보통 배열의 원소에 접근할 떄 볼 수 있음.
* 그림의 나머지 형태는 위 식에서 몇 가지가 빠진 것임.

# 3.4.2 Data Movement Instructions
데이터 이동 명령의 source operand들은 값들이 메모리 혹은 레지스터에 담긴 Imm이여야 함. Destination operand로는 레지스터나 메모리 주소를 지정함.

- `movb` Move byte
- `movw` Move word
- `movl` Move double word
- `movq` Move quad word


* x86_64에서는 Move 명령어의 두 피연산자 모두 메모리를 가리키면 안 된다는 제한이 있다. 즉, 한 메모리 위치에서 다른 메모리 위치로 데이터를 복사하려면 2개의 명령어가 필요하다.
* 대부분의 경우 `mov` 는 destination operand가 가리키는 특정한 레지스터 바이트 혹은 메모리 위치만을 업데이트한다.
* 예외는 `movl`(32비트)의 목적지가 레지스터 일때, 레지스터 값의 높은 순위의 4바이트가 0으로 설정된다.


# `movz` , `movs`
`movz` 계열 명령어들은 남은 바이트를 0으로 채운다. 그러나 `movs` 명령어들은 `sign extension`된 값들을 채운다. 그리고 source operand의 `MSB(Most Significant Bit)`를 복제한다.

# 3.4.3 Data Movement Example
- C code

```c
long exchange(long *xp, long y) {
	long x = *xp;
    *xp = y;
    return x;
}
```

- Assembly code

```assembly
exchange:
	movq (%rdi), (%rax)
    	movq %rsi, (%rdi)
    	ret
```

# 위 코드가 유용하지 않은 이유
* C 언어에서 포인터는 단지 주소이다.
* 포인터를 간접참조하는 건 주소를 레지스터로 복사하는 것이고 레지스터를 메모리의 레퍼런스로 쓰는 것이다.
* 두번째로 지역변수는 보통 메모리 보다 레지스터에 저장되는 것이 빠른데 왜냐하면 레지스터에 접근하는 것이 더 빠르기 때문이다.

최적화된 코드

```assembly
_exchange:
LFB0:
       	pushq  	%rbp
LCFI0:
       	movq   	%rsp, %rbp
LCFI1:
       	movq   	%rdi, -24(%rbp)
       	movq   	%rsi, -32(%rbp)
       	movq   	-24(%rbp), %rax
       	movq   	(%rax), %rax
       	movq   	%rax, -8(%rbp)
       	movq   	-24(%rbp), %rax
       	movq   	-32(%rbp), %rdx
       	movq   	%rdx, (%rax)
       	movq   	-8(%rbp), %rax
       	popq   	%rbp
LCFI2:
       	ret
```


# 3.4.4 Pushing and Popping Stack Data
* x86_64 에서는 프로그램 스택이 메모리의 특정 영역을 차지한다. 그리고 스택애서 top element 가 가장 낮은 주소를 차지 하고 있다. %rsp 스택 포인터가 top 스택 원소의 주소를 가지고 있다.
* 스택에 quad word(8바이트) 를 push 할때는 먼저 스택 포인터를 8만큼 감소시키고 값을 새로운 top 주소에 쓰는 것이다.
* 스택에서 값을 꺼낼때 (pop)할 때는 원래대로 top 포인터를 8만큼 증가시키면 우리가 꺼낸 값 0x123이 여전히 메모리를 가리키고 있다. (다른 푸시 연산이 있기 전까지는) 그러나 stack의 탑은 언제나 %rsp 가 가리키는 주소로 유지된다.


# 3.5. Arithmetic and Logical Operations
### 3.5.1 Load Effective Address
* leaq 명렁어는 movq 명령어의 변종이다. 메모리로부터 데이터를 읽어 레지스터로 보내지만 메모리를 참조하지 않는다.
* 첫 피연산자가 메모리 레퍼런스지만 지정된 위치를 읽는 대신 이 명령은 destination에 효과적인 주소를 복사한다.
* operand에 &이 달려있는 것처럼 이 명령은 나중에 오는 메모리 레퍼런스를 위한 포인터를 만들떄도 쓰인다.
* 다른 산술 연산을 묘사할때도 쓰일 수 있다. 예를 들어 `%rdx` 가 x라는 값을 가지고 있을 때  `leaq 7(%rdx, %rdx,4)`를 하면  `5x+7` 이 된다.
* Destination operand는 반드시 레지스터여야 한다.


# 3.5.2 Unary and Binary operation
- Unary
	- 단항 연산은 operand가 메모리나 레지스터 위치이다.
	- 예를 들어 `incq (%rsp)`는 스택의 8byte(quad word) `top` 원소가 증가하게 된다. 이 문법은 C의 ++나 -- 와 같다.
- Binary
	- 다음 이항 연산 그룹은 C의 `x-=y` 같은 구문을 연상시킨다. 예를 들어 `subq %rax , %rdx` 같은 명령은 `%rdx`를 `%rax`의 값으로 감소시킨다.


# 3.5.3 Shift Operations
* Shift 명령어들은 이동할 양을 `Imm`이나 단일 바이트 레지스터인 %cl로 정할 수 있다. (이 명령어들은 오직 한 레지스터만을 피연산자로 쓴다는 점에서 이상하다)
* x86_64에서는 `w`비트의 길이를 가진 데이터 값으로 동작하는 쉬프트 명령어는 쉬프트의 양을 레지스터 `%cl`의 낮은 순서 `m`비트로부터 결정하다. (`2^m =w`)  높은 순서의 비트들은 무시된다.
* 예를 들어 `%cl` 이 `0xFF`라면 `salb` 는 7만큼 쉬프트 (w가 8이므로 m 은 3이고 0xFF의 낮은 3비트의 값은 7이기 때문이다)



# 3.6.1. Condition codes
- CF: Carry flag. 가장 최근의 연산에서 MSB에 자리 올림이 발생한 상황.
- 가장 최근의 연산이 부호가 없는 연산의 오버플로우를 감지하기 위해 사용된다.
- ZF: Zero flag: 가장 최근 연산이 0
- SF: Sign flag. 가장 최근 연산이 음수
- OF: Overflow flag: 가장 최근 연산이 2의 보수 오버플로우를 일으킴
- Example

```
CF (unsigned) t < (unsigned) a Unsigned overflow
ZF (t==0)  0
SF (t<0) Negative
OF (a < 0 == b < 0) && (t < 0 != a < 0)  Signed Overflow
```
